# 5.4 Running the Mech
It’s finally time to run the code on the robot and see if our mechanism works  
This is where we need to be very careful because it is usually possible to damage the robot by having mechanisms whack each other or by burning out motors  
When you first run a mechanism, run it very slowly and for short periods of time  
To start we need to deploy our code to the robot  
Turn on your robot and connect to it  
Now open the command pallet and run ‘deploy robot code’  
If you get a message like ‘build failed’, look at the stack trace and try to figure out what is wrong with the code  
Usually, it is syntax errors or small mistakes  
Sometimes you can find other people experiencing similar issues on Chief Delphi (the FRC forum)  
Once your code is deployed, open advantage scope and plot your mechanism position or veloctity on a line graph (note: you may need to set your team # in advantage scope before it will connect, it’s the same with elastic)  
Sometimes code repeatedly crashes once deployed to the robot  
This can happen for a couple reasons:  
Code issues (such as null pointer) -> check stack trace of crash and find code bug  
Firmware issues -> your roborio, PDH, motor controllers, motors, CANivore, or sensors may be out of date, make sure to update all physical components  
If your mechanism needs to be zeroed:  
Open Elastic and find your button in the widget menu  
Drag it onto the screen  
Do the same for brake mode and coast mode  
Try manually moving the physical mechanism to zero and pressing the button  
Advantage scope should log the mechanism being at zero  
Now let’s do a sanity check  
Try moving your mechanism to a different position (or spinning it if it’s an angular velocity mech)  
Advantage scope should log a reasonable value  
If it’s a linear position mech, measure the distance you moved it  
If it’s an angular position mech, estimate the angle you moved it  
If it’s an angular vel mech, you shouldn’t get anything over 100 rpm, but you should get some rpm  
If Advantage Scope’s logged value matches your physical observation, you are on the right track  
If not, you may want to check your conversion math in the subsystem code  
It’s finally time to start moving the mechanism  
If you are using CTRE, I would highly suggest using Pheonix tuner X’s native tools for tuning:  
https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/controlling-devices.html   
If you are using REV, this is why we have tunable numbers in our code  
For instructions on tuning your mechanism:  
5.4.A: Position Mech  
5.4.B: Velocity Mech  
For position mechanisms, the first step is almost always to tune the G constant (unless your mechanism is linear and perfectly horizontal, is light enough to not be concerned with gravity or rotates about the x-y plane)  
Remember, G is the amount of power the motor always puts out to resist gravity  
Make sure the gravity type is correct in your code if using CTRE  
For linear mechanisms, we can always put out the same voltage to resist gravity  
For rotating mechanism, like an arm, we need more power when the arm is horizontal than straight up. The power we need is proportional to cos(Ѳ)  
CTRE will do these calculations automatically for the g constant. To my knowledge, for REV you will need pass in a tunable amount as a feedforward: https://docs.revrobotics.com/revlib/spark/closed-loop/getting-started-with-pid-tuning   
If using REV and an arm, you will need to take cos(Ѳ) into account manually  
Now try setting g to incrementally bigger values (after setting all other constants to 0) while being in the position control mode  
The goal is for the mechanism to start moving very very slowly; once you reach this, go back to the last value where it didn’t  
NOTE: You may have the WRONG invert on your motor, if the motor is trying to spin the wrong direction, stop the motor, flip your invert before something breaks.  
If you are using an arm, make sure the arm is able to hold its position at all angles  
Now up the P constant to a small value  
Keep upping it until the mechanism goes to the target position you set in code  
Note: if using CTRE you may need to have non-zero values for max velocity and target acceleration before it will move  
Once it does, set the voltage to 0, let the mechanism go limp, and turn position control back on  
Take a look at advantage scope and observe how the position approaches the target position  
If you are using an arm, make sure the arm is able to hold its position at all angles  
Now up the P constant to a small value  
Keep upping it until the mechanism goes to the target position you set in code  
Once it does, set the voltage to 0, let the mechanism go limp, and turn position control back on  
Take a look at advantage scope and observe how the position approaches the target position  
It should look like one of the lines on the graph (the blue one is the target position  
If your graph looks like the red one, keep increasing the P constant and repeating the trial until you overshoot, then go back to the last non-overshooting P value  
If your graph looks like the green one or the purple one, your P is too high; lower it until it doesn’t overshoot  
You can also try tuning the I and D constants for even smoother motion: https://docs.wpilib.org/en/stable/docs/software/advanced-controls/introduction/introduction-to-pid.html#introduction-to-pid   
If using CTRE motion magic, you should also tune max velocity and target acceleration  
In general, the voltage you put into your velocity motor is proportional the velocity it will go at  
This is why the V constant will be the most important constant to tune  
Increase your V value until your mechanism reaches your target velocity (eventually) after putting it into velocity control mode  
Note: if using CTRE Motion Magic, your target acceleration needs to be non-zero  
You can check this by looking at the velocity in Advantage Scope  
We can make this snappier  
Your velocity should follow a path similar to the red line on the right  
The blue line is the target velocity  
Start increasing the P constant until you overshoot velocity a little bit like the green line, then go back to the last non-overshooting value  
If using CTRE Motion magic, try adjusting your acceleration as well  
You can also play around with the S and A constants:   
Now your mechanism should get to its target velocity in a reasonable time  
For an intake, this time needs to be very short  
For a shooter, depending on how it’s used, it can take longer to spool up to full speed  
If applicable, try putting a game piece through your mechanism (safely and with a mentor/adult)  
See if the velocity drops noticeably as it goes through  
If the velocity drops quite a bit, especially for an intake/shooter, this is not ideal  
This either means, the mechanism needs to be tuned more or there is physically not enough power or Moment of Inertia to maintain target velocity.   
It can also mean a bad physical gear ratio. This is absolutely something to talk to mechanics about.  
