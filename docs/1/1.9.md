# Classes
Generally, each Java file corresponds to a class  
For example, we are working in App.Java and the class App  
We can create a new class by creating a new file  
Right click on the “src” folder and create a new file called “Student.java”  
Java will autofill this:  
Let’s write a method in Student and run that method in App:  
You need to specify Student.addNumbers so that Java knows where to look to find addNumbers since it isn’t in the App class  
The addNumbers method in Student is ‘public’ so that outside classes can call it. If it was ‘private’ it would only be accessible inside the Student class  
Practice: create a method for cubing a number in Student.java and run it in App.java  
## 1.9.1: Objects
You can also use these new classes to create new variable types  
Java needs instructions on how to create a new variable type  
This is called a constructor  
The constructor is a method that outputs an object of the type of its class  
The name of the constructor needs to match the class  
Constructors should be public  
You don’t need to write static or a return type in constructors  
Instance fields are variables that are specific to a single object  
Instance fields are created outside of methods  
Lets add some:  
There are a couple problems here  
Instance fields usually shouldn’t be accessed directly  
We can add ‘private’ to clarify they should only be accessible inside the class  
Another issue is that these instance fields are going to be the same for every Student object we create, we want each student to have a different favorite class and GPA  
To fix this, we can add arguments (parameters/inputs) to the constructor. Like this:  
Theres a problem here too though  
We’re trying to set our instance fields to the parameters  
But because they have the same names, Java isn’t sure which ones we mean so it always defaults to the parameters  
To fix this, we can add ‘this.’ to the instance fields to clarify that we are referring to the instance fields  
Now we should remove the assignments to “Chemistry” and 3 because they will be assigned later  
The variables will be assigned in the constructor  
Now we can modify App.java to include the Student information  
The problem is, there’s no way to access or modify the student information  
The solution is getters and setters  
### 1.9.1.1: Getters
A getter is a method that outputs an instance field from a class:  
There is no “static” behind getters  
When there is the word static, that means you can run it by calling [class name].[method name]  
But when static doesn’t exist, you must create (or instantiate) an object of the type of that class. Then you call [object name].[method name].  
Example:   
Practice:   
Create a getter for GPA  
Print the GPA of the student objects in App.java  
### 1.9.1.2: Setters
Sometimes we want to change instance fields  
After all:  
Students’ favorite classes change all the time  
Students’ GPA changes all the time  
The same applies to FRC. You may want to get the velocity of your shooter, or you may want to set the velocity of your shooter.  
A setter doesn’t have a return type because you aren’t getting anything back. You are just changing something. So the return type is ‘void’.  
A setter does have an argument because you want to tell the object what to change the instance field to.  
Ex:  
Again, we need to use ‘this.’ because we have two variables named ‘favoriteClass’, the instance field and the parameter.  
Now in App.java  
Practice:   
create a setter for GPA  
Modify the values in App.java  
Print the modified values  
## 1.9.2: Inheritance
Inheritance is useful when you want to create multiple types that share properties  
For example, a Dog class and a Cat class would share properties such as name and diet, but petting each animal may result in different outcomes  
Dog might also have a walkLength attribute  
Cat might also have a sleepLength attribute  
To remedy this in Java, we can have a Pet class that has the stuff shared between pets and then extend the Pet class with Cat or Dog specific stuff.  
Create a Pet file and class that has instance fields name and diet  
Include getters and setters for name and diet  
Include a method called “pet”, that prints “Your pet is happy”  
Create a Dog file and class:  
The word ‘extends’ means the Dog class is an extension of the Pet class and therefore inherits methods from Pet  
‘super()’ refers to the constructor of the Pet class. When we run the Dog constructor, it calls the Pet constructor and gives the Dog the name and diet information  
Now add an instance field to Dog for walkLength and include a getter and setter  
Now, we can test this  
In App.java, Create a Pet object and a Dog object  
Call ‘pet’  
Call ‘getDiet’ on both and print the result  
Call ‘getWalkLength’ on the Dog object and print the result  
Under the hood, the Dog  object is actually also a Pet object. It just has extra functionality.  
Now Create a Cat class  
Overrides Pet  
Includes extra instance field: sleepLength  
Create a Cat object in App.java  
Call ‘pet’  
Print result of ‘getDiet’  
Print result of ‘getSleepLength’  
Now we can “override” the ‘pet’ method of Pet in Cat  
To do this, add a ‘pet’ method in Dog  
Make it print “Purrrr……”  
Run the program again, observe the output of ‘pet’ on the cat  
Now Create a Cat class  
Overrides Pet  
Includes extra instance field: sleepLength  
Create a Cat object in App.java  
Call ‘pet’  
Print result of ‘getDiet’  
Print result of ‘getSleepLength’  
Now we can “override” the ‘pet’ method of Pet in Cat  
To do this, add a ‘pet’ method in Dog  
Make it print “Purrrr……”  
Run the program again, observe the output of ‘pet’ on the cat  
Now add Pet as an instance field to Student  
Give one of your student objects a cat  
Give one of your student objects a dog  
Pet one of the student’s animals by calling [student object].[get pet].pet()  
## 1.9.3: Implementation
Sometimes we don’t need a default method (like Pet having the ‘pur’ method with logic for “Your pet is happy”)  
For example, there may be blueprints to build a house, there may be blueprints to build a school.   
Building a “building” is so vague that there aren’t blueprints to build a generic building  
Make a Building class, a School class, and a House class  
To accomplish what we are describing, change Building to be an Interface:  
Now add ‘implements Building’ to the House class  
Now add a ‘build’ method to the Building interface  
Java doesn’t like it because by adding brackets, we implied that we have added functionality to build in the Building interface  
Remember, Building shouldn’t have any logic for ‘build’  
Remove the brackets  
Now add a keyword: ‘abstract’  
This tells Java that the build method is not meant to be a standalone method of Building, but a method that will be overridden in child classes  
In House there is now an error  
Hover over the error  
Click “quick fix”  
Click “add unimplemented methods”  
When you implement an interface, you need to include its methods  
Otherwise, there wouldn’t be any logic  
The ‘@Override’ text before the ‘build’ method makes sure Java overrides the abstract method in Building  
Now we can replace the logic with printing “Building House”  
Follow this same process for School  
Because neither School or House have a constructor, Java gives them an implicit constructor  
Now create a Building array with one House and one School inside of it  
Use an enhanced for loop to iterate over that array calling build on each object  
You should get different outputs for each object  
## 1.9.4: Subclasses
Subclasses are pretty simple  
Create a class called “Constants”  
In that class, create a class called “ElevatorConstants” and “ShooterConstants”  
Add these variables:  
They are public because we want other classes to be able to access this information  
They are static because we don’t want to instantiate an ElevatorConstants object to access the elevator height, we just want to access it directly  
They are final so that they cannot be changed later. They are constants after all.  
They are in all caps to clarify they are constants  
In App.java, print the elevator height  