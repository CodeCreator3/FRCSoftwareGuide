# 4.1 Advantage Kit
WPILib has a class for NetworkTables which has all the functionality we need: https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/networktables/NetworkTable.html 
However, the team that made Advantage Scope, Mechanical Advantage #6328, also created ‘Advantage Kit’
Advantage Kit is basically a library that can be added to FRC code to handle logging data to NetworkTables
However, installing Advantage Kit is not as simple as adding another vendor dep
There is a way to convert existing projects like ours into advantage kit projects: https://docs.advantagekit.org/getting-started/installation/existing-projects 
You may go through this process if you’d like
However, there are a lot of steps involved and for us it will be simpler to download one of Advantage Kit’s template projects and start from there
Download a template project for your robot (based on your type of drivetrain): https://github.com/Mechanical-Advantage/AdvantageKit/releases 
Here are docs explaining more about template projects: https://docs.advantagekit.org/category/template-projects 
If you aren’t sure which template to choose, use the vision template
Now extract the folder to a new folder (called “FRCSoftwareTrainingAK,” or whatever you like) in the same base directory where your original project is stored
Now make that folder into a personal git repository using GitHub CLI
Install GitHub CLI: https://cli.github.com/ 
Create the repo: https://cli.github.com/manual/gh_repo_create 
The structure of subsystems looks a little different under the Advantage Kit format, but fundamentally it’s the same:
Send commands to the motors
Read information from the motors
Our new version of our subsystem will have 3 layers
Top level Subsystem (ex: Elevator.Java)
Extends SubsystemBase
Abstract IO (ex: ElevatorIO.Java)
IO implementation (ex: ElevatorIOReal.Java)
Implements abstract IO
Follow this format and make these classes for your subsystem (for Elevator.java, use WPILib’s create subsystem functionality)
The abstract IO is technically not a class, but an interface, so change that accordingly
The top level class is what is called by other classes in the code
This is how other parts of the code get information from the mechanism and send information to the mechanism
The IO layer (the other two files) can be thought of as one layer
This is because the IO implementation or ‘real’ class will implement and therefore become an implementation of the abstract IO layer
The job of the real class is to deal with the motor itself
The top level will send commands and receive information from the IO layer
The reason it is set up this way is so that we can have different implementations of the IO
For example, imagine you want to be able to swap out a TalonFX motor for a SparkMAX motor at competition (bad idea, but possible)
You could have one IO implementation for TalonFX and one IO implementation for SparkMAX
The most common way this structure is used is for simulation
You could have an ‘ElevatorIOSim.java’ class as well, which can interact with the simulation
The takeaway is that the IO implementation will take methods like ‘setHeight’ that are in the abstract IO and give the functionality for setting the height of the mechanism
The top level class will have logic that doesn’t change based on the IO implementation
For example, Elevator.java might have a ‘setScoringHeight’ method that calls the ‘setHeight’ method of the IO class with a particular height
Additionally, the IO will give information about the motor to the top level class
This information can also be automatically logged by Advantage Kit
Official information on IO: https://docs.advantagekit.org/data-flow/recording-inputs/io-interfaces 
Now it’s time to convert our old subsystem into the new format
Copy the methods and instance fields from your old subsystem to the ‘Real’ class (except periodic)
Rename the constructor
Add those methods as abstract methods to the abstract IO class (except the constructor)
This will mean removing the logic from the methods as well
Now add the @Override keyword before each method in the real class (except constructor)
Now add those same methods (except the constructor) to the top-level class
Remove all logic from the inside of those methods (Java will get mad, that is okay)
Add a constructor to the top level
Add an instance field that is the abstract IO class and set it in the constructor with a parameter
Now replace method logic with ‘io.[methodName]’ or ‘return io.[methodName]’
Now calling something from the top level will send commands to the bottom level (the IO)
Now we need to find a way to log information to NetworkTables so we can view it in Advantage Scope
Firstly, lets add a class to the abstract IO which stores the values we want to log
Create a subclass called ‘[SubsystemName]Inputs’ in the abstract IO
Add variables for the information you want to log
This usually includes
Device connected?
Position
Velocity 
Voltage
Current
Temperature
However, you can tailor it to the mechanism you have
Elevator ex:
Advantage Kit makes it very easy to log this information
Add the keyword @AutoLog before the subclass
Elevator ex:
Now we need to update the values of the subclass
We can do this from the io implementation
Create a new method called “updateInputs” in the io implementation which has the subclass as a parameter
Add an abstract version of that method to the abstract class
Override that abstract method in the io implementation
Now update the variables of the inputs subclass in that method using motor methods
CTRE Elevator ex:
You will need to use StatusSignals if you use CTRE. They are similar to suppliers: https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/status-signals.html 
Now you can add a [SubsystemName]Inputs object as an instance field to the top level
Then in periodic you can call the UpdateInputs method of the io object using the new inputs object
Lastly, lets add methods to get information about our mechanism for other classes in our robot program
Add getter methods for position or velocity depending on your mechanism (retrieve this information from the inputs object)
Congratulations, your subsystem has been converted into the Advantage Kit format!