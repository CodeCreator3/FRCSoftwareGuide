# 3.6 Creating a Subsystem
Go to the corresponding section for the subsystem you chose  
3.6.A: Linear Mechanism (Elevator, ect.)  
3.6.B: Angular Pos Mechanism (Arm, ect.)  
3.6.C: Angular Vel Mechanism (Intake, ect.)  
Do one mechanism, then move onto the Advantage Kit/Scope chapter and Commands chapter before writing another one  
If your mechanism is differential, I would suggest avoiding this as your first subsystem. Here is a phoenix 6 class used for diffy mechs: https://api.ctr-electronics.com/phoenix6/release/java/com/ctre/phoenix6/mechanisms/DifferentialMechanism.html   
For the linear mechanism slides I am going to refer to an elevator  
If you aren’t using an elevator, replace where I say ‘height’ with ‘displacement’ and where I say ‘elevator’ with whatever your mechanism is  
You may or may not need to deal with gravity depending on the angle of your linear mechanism  
Set your PID to a low P (0.02) and 0 for I and D for now in the constructor where you configure the motor  
If using CTRE, also set motion magic config: https://v6.docs.ctr-electronics.com/en/latest/docs/api-reference/device-specific/talonfx/motion-magic.html   
Now we need a method to set the height of the elevator (specifically, the height of the carriage of the elevator. If you don’t know what that means, ask the person who designed your elevator)  
There is usually a method of the motor object you can call to set the motor position  
For CTRE, you need to give it a control request. There are multiple options for this, but I would suggest a ‘MotionMagicVoltage’ request  
When you give the motor a number, you are not telling it what height the elevator should go to (the motor doesn’t know it’s attached to an elevator)  
Instead, you give it motor rotations  
This means that if we want a method that takes in the height as a parameter, we need to convert height to motor rotations  
There are two import factors in this conversion, winch (or pulley) circumference and gear ratio  
This is generally the formula you will use for the conversion (pulley and winch diameters are interchangeable mathematically)  
Put these constants in your ElevatorConstants class in Constants  
You will most likely need to talk to the designer of your robot arm to get the gear ratio  
Note that ‘INCHES_TO_MOTOR_ROT’ should be multiplied by the number of inches you want the elevator reach to get the number of motor rotations  
Now write the method to set the height of the elevator  
It should take in the height you want the elevator to go to  
It should scale that to the rotations the motor should go to  
It should tell the motor to go to that position  
Quick safety measure:   
add a constant for your elevator max height (make sure to label the constant as being in inches)  
Use MathUtil.clamp to clamp the inches parameter between 0 and the max height  
This will prevent your elevator from trying to go to an unreasonable position  
If you know how, you might even want to log a warning when the height is being clamped (or use System.out.println())  
We will discuss how to log warnings later  
CTRE example:  
The core functionality is now done. In theory, we should be able to move the elevator  
There is still an issue  
When the motor wakes up after you turn on the robot, it assumes it is at zero position  
Sometimes, the robot can be turned on when the motor is not at zero position  
In this situation, we need a way to tell the elevator motor that it is at zero position after turning it on (this is typically called “zeroing”.   One might say “I zeroed the robot; we are ready for the match”)  
Some robots use Time of Flight (ToF) sensors to sense the position of the elevator at all times. If your robot has one, you can ignore it for now, but you may want to add that functionality in later.  
Most motors have a setPosition or a setSensorPosition method  
Make a method in your Elevator class called ‘resetSensorPosition’  
Make it set the motor/sensor position to zero  
Another method you may want is ‘setNeutralMode’ with a parameter for the neutral mode (brake or coast)  
This will set the motor config to have a selected neutral mode  
This is very useful for when a technician wants to freely move a robot mechanism around while the robot is disabled  
Write the ‘setNeutralMode’ method  
Here is an example of the setNeutralMode method for CTRE  
It returns a boolean for whether the status of the motor is okay  
For the angular position mechanism slides I am going to refer to an arm  
If you aren’t using an arm, replace where I say ‘arm’ with whatever your mechanism is  
Set your PID to a low P (0.02) and 0 for I and D for now in the constructor where you configure the motor  
If using CTRE, also set motion magic config: https://v6.docs.ctr-electronics.com/en/latest/docs/api-reference/device-specific/talonfx/motion-magic.html   
Now we need a method to set the angle of the arm   
There is usually a method of the motor object you can call to set the motor position  
For CTRE, you need to give it a control request. There are multiple options for this, but I would suggest a ‘MotionMagicVoltage’ request  
Add a GEAR_RATIO constant to an ArmConstants class in Constants  
You will most likely need to talk to the designer of your robot arm to get the gear ratio  
You can configure your motor to know what the gear ratio is:  
This allows us to put in the arm angle we want into the ‘setControl’ motor method  
Now write the method to set the angle of the arm  
For the parameter of the angle, use a Rotation2d object  
It should tell the motor to go to that position  
Quick safety measure:   
Most arms have a min and max angle (unless there is a turret involved)  
If so, add Rotation2d constants for the min and max angle (you get to choose where Ѳ=0°)  
Clamp the angle parameter of the method using MathUtil.clamp  
This will prevent your arm from trying to go to an unreasonable position  
If you know how, you might even want to log a warning when the angle is being clamped (or use System.out.println())  
We will discuss how to log warnings later  
If your angular position mechanism doesn’t have a min and max angle (aka it’s a turret):   
You can pretend the min and max angles are 0 and 360 degrees for now, or  
Try continuous wrap with CTRE: https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/device-specific/talonfx/closed-loop-requests.html   
REV Robotics most likely has similar functionality  
CTRE example:  
The core functionality is now done. In theory, we should be able to turn the arm  
There is still an issue  
When the motor wakes up after you turn on the robot, it assumes it is at zero position  
Sometimes, the robot can be turned on when the motor is not at zero position  
In this situation, we need a way to tell the arm motor where zero actually is (this is typically called “zeroing”. One might say “I zeroed the robot; we are ready for the match”)  
The core functionality is now done. In theory, we should be able to turn the arm  
There is still an issue  
When the motor wakes up after you turn on the robot, it assumes it is at zero position  
Sometimes, the robot can be turned on when the motor is not at zero position  
In this situation, we need a way to tell the arm motor where zero actually is (this is typically called “zeroing”. One might say “I zeroed the robot; we are ready for the match”)  
Some mechanisms use magnetic encoders which can keep track of the mechanism position even after the robot is turned off: https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/cancoder/index.html   
This is why you don’t need to zero swerve modules   
If your mechanism has a magnetic encoder, you can ignore it for now, but you will want to add that functionality in later  
Most motors have a setPosition or a setSensorPosition method  
Make a method in your Arm class called ‘resetSensorPosition’  
Make it set the motor/sensor position to the min angle constant (or whatever angle you prefer to zero it to)  
Another method you may want is ‘setNeutralMode’ with a parameter for the neutral mode (brake or coast)  
This will set the motor config to have a selected neutral mode  
This is very useful for when a technician wants to freely move a robot mechanism around while the robot is disabled  
Write the ‘setNeutralMode’ method  
Here is an example of the setNeutralMode method for CTRE  
It returns a boolean for whether the status of the motor is okay  
For the angular velocity mechanism slides I am going to refer to an intake  
If you aren’t using an intake, replace where I say ‘intake’ with whatever your mechanism is  
Many teams simply set a voltage for their intake (or flywheel) to run at when intaking and shooting gamepieces  
They then tune that voltage based on how gamepieces react  
There are a couple major flaws  
When resistance comes to a voltage controlled mechanism, it will slow the mechanism. We want consistent speed.  
Controlling things with velocity allows us to have fine control over its speed rather than guessing with voltage  
There are situations where you may want open loop voltage control (e.g. grabbing algae off the reef in 2025). However, these are pretty niche.
For velocity control, you can’t use the same exact logic as you do for a PID  
Let’s say your velocity is 500 RPM and you want it to be 1000 RPM  
With a PID, you take the difference and multiply by a constant to get the motor output (ignoring I and D)  
But imagine what happens as we get closer to 1000 RPM  
The motor output becomes zero  
Unfortunately, because of friction and other factors, this means we would never actually reach 1000 RPM  
The solution to this problem is an SVAP  
The P constant means the same thing it did in a PID  
The most important constants in velocity control are V and P  
The V factor is feedforward  
V is basically multiplied by the target velocity and added to the total voltage  
https://docs.wpilib.org/en/stable/docs/software/advanced-controls/introduction/introduction-to-feedforward.html#introduction-to-dc-motor-feedforward   
Set your SVAP to a low V (0.02) and 0 for S, A, and P for now in the constructor where you configure the motor  
If using CTRE, also set motion magic config: https://v6.docs.ctr-electronics.com/en/latest/docs/api-reference/device-specific/talonfx/motion-magic.html   
Now we need a method to set the velocity of the intake   
There is usually a method of the motor object you can call to set the motor velocity  
For CTRE, you need to give it a control request. There are multiple options for this, but I would suggest a ‘MotionMagicVelocityVoltage’ request  
Add a GEAR_RATIO constant to an IntakeConstants class in Constants  
You will most likely need to talk to the designer of your robot intake to get the gear ratio  
You can configure your motor to know what the gear ratio is:  
This allows us to put in the intake velocity we want into the ‘setControl’ motor method  
Now write the method to set the velocity of the intake   
You will want the input of the method to be in rotations per minute and the input to the motor to be rotations per second, so you will need to convert  
It should tell the motor to go to that velocity  
CTRE example:  
Note: we use the Units Library here  
The core functionality is now done. In theory, we should be able to turn the intake  